//===-- Interpreter.h - Abstract Execution Engine Interface -----*- C++ -*-===//
//
//                     The KLEE Symbolic Virtual Machine
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//===----------------------------------------------------------------------===//

#ifndef KLEE_INTERPRETER_H
#define KLEE_INTERPRETER_H

#include <vector>
#include <string>
#include <map>
#include <set>
#include <deque>
#include "klee/Internal/Analysis/ModRefAnalysis.h"
#include "klee/Internal/Analysis/Annotator.h"


struct KTest;

namespace llvm {
class Function;
class Module;
class raw_ostream;
class raw_fd_ostream;
}

namespace klee {
class ExecutionState;
class Interpreter;
class TreeStreamWriter;
struct KFunction;

class InterpreterHandler {
public:
  InterpreterHandler() {}
  virtual ~InterpreterHandler() {}

  virtual llvm::raw_ostream &getInfoStream() const = 0;

  virtual std::string getOutputFilename(const std::string &filename) = 0;
  virtual llvm::raw_fd_ostream *openOutputFile(const std::string &filename, bool openOutputFile = false) = 0;

  virtual void incPathsExplored() = 0;

  virtual void incRecoveryStatesCount() = 0;

  virtual void incGeneratedSlicesCount() = 0;

  virtual void incSnapshotsCount() = 0;

  virtual void processTestCase(const ExecutionState &state,
                               const char *err, 
                               const char *suffix) = 0;
};

class Interpreter {
public:
  /// ModuleOptions - Module level options which can be set when
  /// registering a module with the interpreter.
  struct ModuleOptions {
    std::string LibraryDir;
    std::string EntryPoint;
    bool Optimize;
    bool CheckDivZero;
    bool CheckOvershift;

    ModuleOptions(const std::string &_LibraryDir,
                  const std::string &_EntryPoint, bool _Optimize,
                  bool _CheckDivZero, bool _CheckOvershift)
        : LibraryDir(_LibraryDir), EntryPoint(_EntryPoint), Optimize(_Optimize),
          CheckDivZero(_CheckDivZero), CheckOvershift(_CheckOvershift) {}
  };

  enum LogType
  {
	  STP, //.CVC (STP's native language)
	  KQUERY, //.KQUERY files (kQuery native language)
	  SMTLIB2 //.SMT2 files (SMTLIB version 2 files)
  };

  struct SkippedFunctionOption {
    std::string name;
    /* TODO: change to lines? */
    std::vector<unsigned int> lines;

    SkippedFunctionOption(std::string name, std::vector<unsigned int> &lines) :
      name(name), lines(lines)
    {

    }

  };

  struct ErrorLocationOption {
    std::string filename;
    std::vector<unsigned> lines;

    ErrorLocationOption(std::string filename, std::vector<unsigned> &lines) :
        filename(filename), lines(lines) {}
  };

  /// InterpreterOptions - Options varying the runtime behavior during
  /// interpretation.
  struct InterpreterOptions {
    /// A frequency at which to make concrete reads return constrained
    /// symbolic values. This is used to test the correctness of the
    /// symbolic execution on concrete programs.
    typedef std::map<std::string, std::vector<unsigned> > ErrorLocations;

    unsigned MakeConcreteSymbolic;
    std::vector<SkippedFunctionOption> skippedFunctions;
    std::vector<std::string> inlinedFunctions;
    ErrorLocations errorLocations;
    unsigned int maxErrorCount;

    InterpreterOptions() : 
      MakeConcreteSymbolic(false),
      maxErrorCount(0)
    {

    }
  };

protected:
  InterpreterOptions interpreterOpts;

  Interpreter(InterpreterOptions &_interpreterOpts)
    : interpreterOpts(_interpreterOpts)
  {}

public:
  virtual ~Interpreter() {}

  static Interpreter *create(InterpreterOptions &_interpreterOpts,
                             InterpreterHandler *ih);

  /// Register the module to be executed.  
  ///
  /// \return The final module after it has been optimized, checks
  /// inserted, and modified for interpretation.
  virtual const llvm::Module * 
  setModule(llvm::Module *module, 
            const ModuleOptions &opts) = 0;

  typedef std::pair<unsigned, uint64_t> PSEAllocSite;
  typedef std::pair<std::string, PSEAllocSite> PSEModInfo;
  typedef std::map<PSEModInfo, uint32_t> PSEModInfoToIdMap;

  typedef std::pair<std::string, uint64_t> PSEAllocSiteG;
  typedef std::pair<std::string, PSEAllocSiteG> PSEModInfoG;
  typedef std::map<PSEModInfoG, uint32_t> PSEModInfoToIdMapG;

  typedef std::map<std::string, std::set<unsigned>> PSEModSetMap;
  typedef std::map<unsigned, std::pair<std::set<PSEModInfo>, std::set<PSEModInfoG>>> PSELoadToModInfoMap;

  // supply a tree stream writer which the interpreter will use
  // to record the concrete path (as a stream of '0' and '1' bytes).
  virtual void setPathWriter(TreeStreamWriter *tsw) = 0;

  // supply a tree stream writer which the interpreter will use
  // to record the symbolic path (as a stream of '0' and '1' bytes).
  virtual void setSymbolicPathWriter(TreeStreamWriter *tsw) = 0;

  // supply a test case to replay from. this can be used to drive the
  // interpretation down a user specified path. use null to reset.
  virtual void setReplayKTest(const struct KTest *out) = 0;

  // supply a list of branch decisions specifying which direction to
  // take on forks. this can be used to drive the interpretation down
  // a user specified path. use null to reset.
  virtual void setReplayPath(const std::vector<bool> *path) = 0;

  // supply a set of symbolic bindings that will be used as "seeds"
  // for the search. use null to reset.
  virtual void useSeeds(const std::vector<struct KTest *> *seeds) = 0;

  virtual void runFunctionAsMain(llvm::Function *f,
                                 int argc,
                                 char **argv,
                                 char **envp,
                                 bool branchLevelHalt=false) = 0;

  typedef std::pair<const llvm::Value *, uint64_t> AllocSite;
  typedef std::pair<llvm::Function *, AllocSite> ModInfo;
  typedef std::map<ModInfo, uint32_t> ModInfoToIdMap;

  virtual void runFunctionAsMain2(llvm::Function *f,
                                  int argc,
                                  char **argv,
                                  char **envp,
                                  std::deque<std::deque<unsigned char>> &workList) = 0;

  virtual void setUpperBound(std::vector<unsigned char> path) = 0;
  virtual void setLowerBound(std::vector<unsigned char> path) = 0;
  virtual void setExplorationDepth(const int inExplorationDepth) = 0;
  virtual void setPathFile(std::string inPath) = 0;
  virtual void enablePrefixChecking() = 0;
  virtual void setSearchMode(std::string inSearchMode) = 0;
  virtual void setBrHistFile(std::string inBrHistFile) = 0;
  virtual void setLogFile(std::string inLogFile) = 0;
  virtual void setDataFlowAnalysisStructures(PSEModInfoToIdMap& inPseModInfoToIdMap,
                                            PSEModInfoToIdMapG& inPseModInfoToIdMapG,
                                            PSEModSetMap& inPseModSetMap,
                                            std::set<unsigned>& inBlockingLoads,
                                            std::set<unsigned>& inOverridingStores,
                                            PSELoadToModInfoMap& inPseLoadToModInfoMap)= 0;


  /*** Runtime options ***/

  virtual void setHaltExecution(bool value) = 0;

  virtual void setInhibitForking(bool value) = 0;

  /*** State accessor methods ***/

  virtual unsigned getPathStreamID(const ExecutionState &state) = 0;

  virtual unsigned getSymbolicPathStreamID(const ExecutionState &state) = 0;
  
  virtual void getConstraintLog(const ExecutionState &state,
                                std::string &res,
                                LogType logFormat = STP) = 0;

  virtual bool getSymbolicSolution(const ExecutionState &state, 
                                   std::vector< 
                                   std::pair<std::string,
                                   std::vector<unsigned char> > >
                                   &res) = 0;

  virtual void getCoveredLines(const ExecutionState &state,
                               std::map<const std::string*, std::set<unsigned> > &res) = 0;
};

} // End klee namespace

#endif
